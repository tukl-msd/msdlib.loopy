/*
 * Katja
 * Copyright (C) 2003-2009 see README file for authors
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

package de.hopp.generator;

import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import de.hopp.generator.exceptions.Error;
import de.hopp.generator.exceptions.Warning;

/**
 * Gathers all errors and warning generated by backends (or non-startup frontend parts)
 * The ErrorCollection is almost identical to the ErrorCollection used by Katja.
 * @author Thomas Fischer
 */
public class ErrorCollection {

    // holds all errors and warning
    private final List<Warning> warnings = new LinkedList<Warning>();
    private final List<Error>     errors = new LinkedList<Error>();

    /**
     * Adds an error to the error collection
     * @param error the error to add to the inernal error list
     */
    public void addError(Error error) {
        errors.add(error);
    }

    /**
     * Adds a warning to the error collection
     * @param warning the warning to add to the internal warning list
     */
    public void addWarning(Warning warning) {
        warnings.add(warning);
    }

    /**
     * Prints all error messages stored to IO.error
     * @param IO the IO object to use
     */
    public void showErrors(IOHandler IO) {
        IO.println("ERRORS:");
        for(Error error : errors) {
            IO.error(error.getMessage());
        }
//        // go through all errors
//        for(Error error : errors) {
//
//            // check if it's some simple error
//            if(error instanceof UsageError) {
//                IO.error(error.message());
//
//            // so it's the extended version with line and file
//            } else {
//
//                // a specification error has more info, so cast
//                SpecError specError = (SpecError) error;
//
//                // create the result error string
//                String msg = "";
//
//                // if file name not empty, append file information
//                if(!specError.file().equals("")) {
//
//                    // append file name
//                    msg += "in file "+specError.file();
//
//                    // if line not -1 (no line given), append line information
//                    if(specError.line() > -1) msg += ":"+specError.line();
//                }
//
//                // output error
//                if(msg.length() > 0) IO.error(msg);
//                IO.error(error.message());
//            }
//        }
    }

    /**
     * Prints all warnings store to IO
     * @param IO the IO object to use
     */
    public void showWarnings(IOHandler IO) {

        // show header
        IO.println("WARNINGS:");

        // go through all warnings
        for(Warning warning : warnings) {

//            // create the message
//            String msg = "";
//
//            // if file name not empty, append file information
//            if(!warning.file().equals("")) {
//
//                // append file name
//                msg += "in file "+warning.file();
//
//                // if line not -1 (no line given), append line information
//                if(warning.line() > -1) msg += ":"+warning.line();
//            }

            // output warning
//            if(msg.length() > 0) IO.println(msg);
            IO.warning(warning.getMessage());
        }
    }

    /**
     * Returns the number of errors
     * @return the number of errors
     */
    public int numErrors() {
     return errors.size();
    }

    /**
     * Returns the number of warnings
     * @return the number of warnings
     */
    public int numWarnings() {
        return warnings.size();
    }

    /**
     * Returns wether there is any error so far or not
     * @return wether there is any error so far or not
     */
    public boolean hasErrors() {
        return errors.size() > 0;
    }

    /**
     * Returns wether there is any warning so far or not
     * @return wether there is any warning so far or not
     */
    public boolean hasWarnings() {
        return warnings.size() > 0;
    }

    /**
     * Returns all Katja warnings form the error collection.
     * @return all Katja warnings form the error collection.
     */
    public List<Warning> getWarnings() {
        return Collections.unmodifiableList(warnings);
    }

    /**
     * Returns all Katja errors form the error collection.
     * @return all Katja errors form the error collection.
     */
    public List<Error> getErrors() {
        return Collections.unmodifiableList(errors);
    }
}
